# Remove functions that are not necessary anymore

#########################################################################
# Methods for BASiCS_Chain objects

#' @name BASiCS_Chain-methods
#' @aliases show,BASiCS_Chain-method
#'
#' @title 'show' method for BASiCS_Chain objects
#'
#' @description 'show' method for \code{\linkS4class{BASiCS_Chain}} objects.
#'
#' @param object A \code{\linkS4class{BASiCS_Chain}} object.
#'
#' @return Prints a summary of the properties of \code{object}.
#'
#' @examples
#'
#' Data <- makeExampleBASiCS_Data()
#' Chain <- BASiCS_MCMC(Data, N = 50, Thin = 2, Burn = 2, Regression = FALSE)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#'
#' @rdname BASiCS_Chain-methods
#' @export
setMethod("show",
          signature = "BASiCS_Chain",
          definition = function(object)
          {
            N <- nrow(object@parameters$mu)
            q.bio <- ncol(object@parameters$delta)
            n <- ncol(object@parameters$nu)
            nBatch <- ncol(object@parameters$theta)
            cat("An object of class ", class(object), "\n",
                " ", N, " MCMC samples.\n", sep = "")
            if (!("parameters" %in% methods::slotNames(object))) {
              cat("'BASiCS_Chain' object was generated by an old version of BASiCS")
            }
            else {
              N <- nrow(object@parameters$mu)
              q.bio <- ncol(object@parameters$delta)
              n <- ncol(object@parameters$nu)
              nBatch <- ncol(object@parameters$theta)
              if (nBatch > 1) {
                cat(" Dataset contains ", q.bio, " biological genes and ",
                    n, " cells (", nBatch, " batches). \n", sep = "")
              }
              else {
                cat(" Dataset contains ", q.bio, " biological genes and ",
                    n, " cells (1 batch). \n", sep = "")
              }
              ChainVersion <- object@.__classVersion__$BASiCS_Chain
              ChainVersion <- paste0(ChainVersion[1], ".",
                                     ChainVersion[2], ".",
                                     ChainVersion[3])
              cat(" Object stored using BASiCS version: ", ChainVersion, "\n",
                  "Parameters: ", names(object@parameters), "\n")
            }
          })

#' @name BASiCS_Chain-methods
#' @aliases updateObject,BASiCS_Chain-method
#'
#' @title 'updateObject' method for BASiCS_Chain objects
#'
#' @description 'updateObject' method for \code{\linkS4class{BASiCS_Chain}}
#' objects. It is used to convert outdated \code{\linkS4class{BASiCS_Chain}}
#' objects into a version that is compatible with the Bioconductor release
#' of BASiCS. Do not use this method is \code{\linkS4class{BASiCS_Chain}}
#' already contains a \code{parameters} slot.
#'
#' @param ... Additional arguments of \code{\link[BiocGenerics]{updateObject}}
#' generic method. Not used within BASiCS.
#' @param verbose Additional argument of \code{\link[BiocGenerics]{updateObject}}
#' generic method. Not used within BASiCS.
#'
#' @return Returns an updated \code{\linkS4class{BASiCS_Chain}} object that
#' contains all model parameters in a single slot object (list).
#'
#' @examples
#'
#' # Not run
#' # New_Chain <- updateObject(Old_Chain)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#'
#' @rdname BASiCS_Chain-methods
#' @export
setMethod("updateObject",
          signature = "BASiCS_Chain",
          definition = function(object, ..., verbose = FALSE)
          {
            if (is.null(object@mu)) {
              stop("Object was not created by an older version of BASiCS. \n")
            }

            New_Chain <- newBASiCS_Chain(parameters = list(
                                         mu = object@mu,
                                         delta = object@delta,
                                         phi = object@phi,
                                         s = object@s,
                                         nu = object@nu,
                                         theta = object@theta))

            return(New_Chain)
          })

#' @name Summary
#' @aliases Summary Summary,BASiCS_Chain-method
#'
#' @docType methods
#' @rdname Summary-BASiCS_Chain-method
#'
#' @title 'Summary' method for BASiCS_Chain objects
#'
#' @description For each of the BASiCS parameters (see Vallejos et al 2015),
#' \code{Summary} returns the corresponding postior medians and limits of
#' the high posterior density interval (probabilty equal to \code{prob})
#'
#' @param x A \code{\linkS4class{BASiCS_Chain}} object.
#' @param prob \code{prob} argument for \code{\link[coda]{HPDinterval}} function.
#'
#' @return An object of class \code{\linkS4class{BASiCS_Summary}}.
#'
#' @examples
#'
#' data(ChainSC)
#' SummarySC <- Summary(ChainSC)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#' @export
setMethod("Summary",
          signature = "BASiCS_Chain",
          definition = function(x, prob = 0.95) {

  out <- lapply(x@parameters[names(x@parameters) != "designMatrix"],
    function(n) {
      HPD <- matrix(data = NA, ncol = 3, nrow = ncol(n),
                    dimnames = list(colnames(n), c("median", "lower", "upper")))
      HPD[,1] <- colMedians(n)
      HPD[!is.na(HPD[,1]),2:3] <- coda::HPDinterval(coda::mcmc(n[,!is.na(HPD[,1])]),
                                                    prob=prob)
      HPD
  })

  if ("RefFreq" %in% names(out)) {
    out$RefFreq <- NULL
  }

  new("BASiCS_Summary", parameters = out)
})

#' @name subset
#' @aliases subset subset,BASiCS_Chain-method
#'
#' @docType methods
#' @rdname subset-BASiCS_Chain-method
#'
#' @title A 'subset' method for `BASiCS_Chain`` objects
#'
#' @description This can be used to extract a subset of a `BASiCS_Chain` object.
#' The subset can contain specific genes, cells or MCMC iterations
#'
#' @param x A \code{\linkS4class{BASiCS_Chain}} object.
#' @param Genes A vector of characters indicating what genes will be extracted.
#' @param Cells A vector of characters indicating what cells will be extrated.
#' @param Iterations Numeric vector of positive integers indicating which MCMC
#' iterations will be extracted. The maximum value in \code{Iterations} must be
#' less or equal than the total number of iterations contained in the original
#' \code{\linkS4class{BASiCS_Chain}} object.
#'
#' @return An object of class \code{\linkS4class{BASiCS_Chain}}.
#'
#' @examples
#'
#' data(ChainSC)
#' 
#' # Extracts 3 first genes
#' ChainSC1 <- subset(ChainSC, Genes = rownames(ChainSC)[1:3])
#' # Extracts 3 first cells
#' ChainSC2 <- subset(ChainSC, Cells = colnames(ChainSC)[1:3])
#' # Extracts 10 first iterations
#' ChainSC3 <- subset(ChainSC, Iterations = 1:10)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#'
#' @export
setMethod("subset",
          signature = "BASiCS_Chain",
          definition = function(x, Genes = NULL,
                                Cells = NULL, Iterations = NULL){

            N <- nrow(displayChainBASiCS(x, Param = "mu"))
            q <- ncol(displayChainBASiCS(x, Param = "mu"))
            n <- ncol(displayChainBASiCS(x, Param = "nu"))
            GeneName <- colnames(displayChainBASiCS(x, Param = "mu"))
            CellName <- colnames(displayChainBASiCS(x, Param = "nu"))

            # Checking for valid arguments + assigning default values
            if (is.null(Iterations)) {
              Iterations <- seq_len(N)
            }
            else {
              stopifnot(all(Iterations == floor(Iterations)))
              stopifnot(min(Iterations) >= 1, max(Iterations) <= N )
            }
            if (is.null(Genes)) {
              Genes <- GeneName
            }
            else {
              if (sum(!(Genes %in% GeneName)) > 0) {
                stop("Some elements of 'Genes' are not present in the data")
              }
            }
            if (is.null(Cells)) {
              Cells <- CellName
            }
            else {
              if (sum(!(Cells %in% CellName)) > 0) {
                stop("Some elements of 'Cells' are not present in the data")
              }
            }

            SelGenes <- GeneName %in% Genes
            SelCells <- CellName %in% Cells
            Params <- names(x@parameters)

            out <- list()
            for(p in seq_len(length(Params))) {
              if (Params[p] %in% c("theta", "beta", "sigma2")) {
                out[[p]] <- get(Params[p], x@parameters)[Iterations, , drop = FALSE]
              }
              else {
                if (Params[p] %in% c("mu", "delta", "epsilon")) {
                  Sel <- SelGenes
                }
                if (Params[p] %in% c("phi", "s", "nu")) {
                  Sel <- SelCells
                }
                out[[p]] <- get(Params[p], x@parameters)[Iterations, Sel]
              }
            }
            names(out) <- Params

            # Transform into BASiCS_Chain class object
            out1 <- newBASiCS_Chain(parameters = out)
            out1@.__classVersion__$BASiCS_Chain <- x@.__classVersion__$BASiCS_Chain

            return(out1)
          })


#' @name colnames
#' @aliases colnames colnames,BASiCS_Chain-method
#'
#' @docType methods
#' @rdname colnames-BASiCS_Chain-method
#'
#' @title 'colnames' method for BASiCS_Chain objects
#'
#' @description Returns the labels of cell-specific BASiCS parameters
#'
#' @param x A \code{\linkS4class{BASiCS_Chain}} object.
#'
#' @return An vector of labels
#'
#' @examples
#'
#' data(ChainSC)
#' colnames(ChainSC)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' 
#' @export
setMethod("colnames",
          signature = "BASiCS_Chain",
          definition = function(x) colnames(x@parameters$s))

#' @name rownames
#' @aliases rownames rownames,BASiCS_Chain-method
#'
#' @docType methods
#' @rdname rownames-BASiCS_Chain-method
#'
#' @title 'rownames' method for BASiCS_Chain objects
#'
#' @description Returns the labels of gene-specific BASiCS parameters
#'
#' @param x A \code{\linkS4class{BASiCS_Chain}} object.
#'
#' @return An vector of labels
#'
#' @examples
#'
#' data(ChainSC)
#' rownames(ChainSC)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#'
#' @export
setMethod("rownames",
          signature = "BASiCS_Chain",
          definition = function(x) return(colnames(x@parameters$mu)))

# @importFrom ggExtra ggMarginal 
# @importFrom cowplot plot_grid
#' @name plot-BASiCS_Chain-method
#' @aliases plot plot,BASiCS_Chain-method plot,BASiCS_Chain,ANY-method
#'
#' @docType methods
#' @rdname plot-BASiCS_Chain-method
#'
#' @title 'plot' method for BASiCS_Chain objects
#'
#' @description 'plot' method for \code{\linkS4class{BASiCS_Chain}} objects
#'
#' @param x A \code{\linkS4class{BASiCS_Chain}} object.
#' @param Param Name of the slot to be used for the plot.
#' Possible values: \code{'mu'}, \code{'delta'},
#' \code{'phi'}, \code{'s'}, \code{'nu'}, \code{'theta'},
#' \code{'beta'}, \code{'sigma2'} and \code{'epsilon'}.
#' @param Gene Specifies which gene is requested.
#' Required only if \code{Param = 'mu'} or \code{'delta'}
#' @param Cell Specifies which cell is requested.
#' Required only if \code{Param = 'phi', 's'} or \code{'nu'}
#' @param Batch Specifies which batch is requested.
#' Required only if \code{Param = 'theta'}
#' @param RegressionTerm Specifies which regression coefficient is requested.
#' Required only if \code{Param = 'beta'}
#' @param ylab As in \code{\link[graphics]{par}}.
#' @param xlab As in \code{\link[graphics]{par}}.
#' @param ... Other graphical parameters (see \code{\link[graphics]{par}}).
#'
#' @return A plot object
#'
#' @examples
#'
#' help(BASiCS_MCMC)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#' 
#' @export
setMethod("plot",
          signature = "BASiCS_Chain",
          definition = function(x,
                                Param = "mu",
                                Gene = NULL, Cell = NULL, Batch = 1,
                                RegressionTerm = NULL,
                                ylab = "", xlab = "", ...)
          {
            if (Param %in% c("mu", "delta", "epsilon") & is.null(Gene)) {
              stop("'Gene' value is required")
            }
            if (Param %in% c("phi", "s", "nu") & is.null(Cell)) {
              stop("'Cell' value is required")
            }
            if (Param %in% c("theta") & is.null(Batch)) {
              stop("'Batch' value is required")
            }
            if (Param %in% c("beta") & is.null(RegressionTerm)) {
              stop("'RegressionTerm' value is required")
            }

            if (Param %in% HiddenGeneParams()) {
              Column <- Gene
            } else if (Param %in% HiddenCellParams()) {
              Column <- Cell
            } else if (Param == "theta") {
              Column <- Batch
            } else if (Param == "beta") {
              Column <- RegressionTerm
            }
            if (xlab == "") {
              xlab <- "Iteration"
            }
            if (ylab == "") {
              ylab <- bquote(.(Param)[.(Column)])
            }
            
            DF1 <- data.frame("Iteration" = seq_len(nrow(x@parameters[[Param]])),
                              "Draws" = x@parameters[[Param]][, Column])
            # Code inspired by https://stackoverflow.com/questions/17788859/acf-plot-with-ggplot2-setting-width-of-geom-bar
            MyAcf <- acf(x@parameters[[Param]][,Column], plot = FALSE)
            DF2 <- with(MyAcf, data.frame(lag, acf))
            
            # Traceplot
            p1 <- ggplot2::ggplot(DF1) + 
              ggplot2::geom_point(ggplot2::aes_string(x = "Iteration", y = "Draws"),
                                  col = grDevices::adjustcolor("white", 
                                                               alpha.f = 0) ) + 
              ggplot2::geom_line(ggplot2::aes_string(x= "Iteration", y = "Draws")) + 
              ggplot2::labs(title = colnames(x@parameters[[Param]])[Column],
                            x = "Iteration", 
                            y = "Parameter value") + 
              ggplot2::theme_classic()
            p1 <- ggExtra::ggMarginal(p1, type = "histogram", margins = "y")
              
            p2 <- ggplot2::ggplot(DF2, ggplot2::aes_string(x = "lag", y = "acf")) + 
              ggplot2::theme_classic() + 
              ggplot2::geom_hline(ggplot2::aes(yintercept = 0)) + 
              ggplot2::geom_segment(mapping = ggplot2::aes_string(xend = "lag", yend = 0)) +
              ggplot2::ggtitle(colnames(x@parameters[[Param]])[Column])
            
            cowplot::plot_grid(p1, p2)
            
          })

#' @name displayChainBASiCS-BASiCS_Chain-method
#' @aliases displayChainBASiCS displayChainBASiCS,BASiCS_Chain-method
#'
#' @docType methods
#' @rdname displayChainBASiCS-BASiCS_Chain-method
#'
#' @title Accessors for the slots of a BASiCS_Chain object
#'
#' @description Accessors for the slots of a \code{\linkS4class{BASiCS_Chain}}
#'
#' @param object an object of class \code{\linkS4class{BASiCS_Chain}}
#' @param Param Name of the slot to be used for the accessed.
#' Possible values: \code{'mu'}, \code{'delta'}, \code{'phi'},
#' \code{'s'}, \code{'nu'}, \code{'theta'}, \code{'beta'},
#' \code{'sigma2'} and \code{'epsilon'}.
#'
#' @return The requested slot of a \code{\linkS4class{BASiCS_Chain}} object
#'
#' @examples
#'
#' help(BASiCS_MCMC)
#'
#' @seealso \code{\linkS4class{BASiCS_Chain}}
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#'
#' @export
setMethod("displayChainBASiCS",
          signature = "BASiCS_Chain",
          definition = HiddenGetParam)

#########################################################################
# Methods for BASiCS_Summary objects

#' @name BASiCS_Summary-methods
#' @aliases show,BASiCS_Summary-method
#'
#' @title 'show' method for BASiCS_Summary objects
#'
#' @description 'show' method for \code{\linkS4class{BASiCS_Summary}} objects.
#'
#' @param object A \code{\linkS4class{BASiCS_Summary}} object.
#'
#' @return Prints a summary of the properties of \code{object}.
#'
#' @examples
#'
#' data(ChainSC)
#' show(ChainSC)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#'
#' @rdname BASiCS_Summary-methods
#' 
#' @export
setMethod("show",
          signature = "BASiCS_Summary",
          definition = function(object)
          {
            q <- nrow(object@parameters$mu)
            q.bio <- nrow(object@parameters$delta)
            n <- nrow(object@parameters$phi)
            nBatch <- nrow(object@parameters$theta)
            cat("An object of class ", class(object), "\n",
                " Contains posterior medians and the limits of the \n",
                " HPD interval for all BASiCS model parameters.\n")

            if (nBatch > 1) {
              cat("  Dataset contains ", q, " genes ",
                  "(", q.bio, " biological and ", q-q.bio, " technical) \n",
                  "  and ", n, " cells (", nBatch, " batches). \n", sep = "")
            }
            else {
              cat("  Dataset contains ", q, " genes ",
                  "(", q.bio, " biological and ", q-q.bio, " technical) \n",
                  "  and ", n, " cells (1 batch). \n", sep = "")
            }
            ChainVersion <- object@.__classVersion__$BASiCS_Summary
            ChainVersion <- paste0(ChainVersion[1], ".",
                                   ChainVersion[2], ".",
                                   ChainVersion[3])
            cat("  Object stored using BASiCS version: ", ChainVersion, "\n",
                " Parameters: ", names(object@parameters), "\n")
          })




#' @name plot-BASiCS_Summary-method
#' @aliases plot,BASiCS_Summary-method, plot,BASiCS_Summary,ANY-method
#'
#' @docType methods
#' @rdname plot-BASiCS_Summary-method
#'
#' @title 'plot' method for BASiCS_Summary objects
#'
#' @description 'plot' method for \code{\linkS4class{BASiCS_Summary}} objects
#'
#' @param x A \code{\linkS4class{BASiCS_Summary}} object.
#' @param Param Name of the slot to be used for the plot.
#' Possible values: \code{'mu'}, \code{'delta'},
#' \code{'phi'}, \code{'s'}, \code{'nu'}, \code{'theta'}, \code{'beta'},
#' \code{'sigma2'} and \code{'epsilon'}.
#' @param Param2 Name of the second slot to be used for the plot.
#' Possible values: \code{'mu'}, \code{'delta'}, \code{'epsilon'},
#' \code{'phi'}, \code{'s'} and \code{'nu'}
#' (combinations between gene-specific and
#' cell-specific parameters are not admitted).
#' @param Genes Specifies which genes are requested.
#' Required only if \code{Param = 'mu'}, \code{'delta'} or \code{'epsilon'}.
#' @param Cells Specifies which cells are requested.
#' Required only if \code{Param = 'phi', 's'} or \code{'nu'}
#' @param Batches Specifies which batches are requested.
#' Required only if \code{Param = 'theta'}
#' @param RegressionTerms Specifies which regression coefficients are requested.
#' Required only if \code{Param = 'beta'}
#'
#' @param xlab As in \code{\link[graphics]{par}}.
#' @param ylab As in \code{\link[graphics]{par}}.
#' @param xlim As in \code{\link[graphics]{par}}.
#' @param ylim As in \code{\link[graphics]{par}}.
#' @param pch As in \code{\link[graphics]{par}}.
#' @param col As in \code{\link[graphics]{par}}.
#' @param bty As in \code{\link[graphics]{par}}.
#' @param SmoothPlot Logical parameter. If \code{TRUE},
#' transparency will be added to the color of the dots.
#' @param ... Other graphical parameters (see \code{\link[graphics]{par}}).
#'
#' @return A plot object
#'
#' @examples
#'
#' help(BASiCS_MCMC)
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#'
#' @export
setMethod("plot",
          signature = "BASiCS_Summary",
          definition = function(x, Param = "mu", Param2 = NULL,
                                Genes = NULL, Cells = NULL, Batches = NULL,
                                RegressionTerms = NULL,
                                xlab = "", ylab = "", xlim = "", ylim = NULL,
                                pch = 16, col = "blue", bty = "n",
                                SmoothPlot = TRUE, ...)
          {

            if (!(Param %in% names(x@parameters))) {
              stop("'Param' argument is invalid")
            }

            q <- nrow(x@parameters$mu)
            q.bio <- nrow(x@parameters$delta)
            n <- nrow(x@parameters$s)
            nBatch <- nrow(x@parameters$theta)

            if (is.null(Genes)) {
              Genes <- seq_len(q.bio)
            }
            if (is.null(Cells)) {
              Cells <- seq_len(n)
            }
            if (is.null(Batches)) {
              Batches <- seq_len(nBatch)
            }

            if("beta" %in% names(x@parameters)) {
              k <- nrow(x@parameters$beta)
              if (is.null(RegressionTerms)) {
                RegressionTerms <- seq_len(k)
              }
            }

            if (is.null(Param2)) {
              object <- x@parameters[[Param]]

              if (Param %in% HiddenGeneParams()) {
                Columns <- Genes
                ylabInd <- "i"
                if (xlab == "") {
                  xlab <- "Gene"
                }
              } else if (Param %in% HiddenCellParams()) {
                Columns <- Cells
                ylabInd <- "j"
                if (xlab == "") {
                  xlab <- "Cell"
                }
              } else if (Param == "theta") {
                Columns <- Batches
                ylabInd <- "b"
                if (xlab == "") {
                  xlab <- "Batch"
                }
              } else if (Param == "beta") {
                Columns <- RegressionTerms
                ylabInd <- "k"
                if (xlab == "") {
                  xlab <- "Regression term"
                }
              } else if (Param == "sigma2") {
                object <- x@parameters$sigma2
                Columns <- 1
                ylabInd <- "i"
                if (xlab == "") {
                  xlab <- "Gene"
                }
              }

              if (ylab == "") {
                ylab <- bquote(.(Param)[.(ylabInd)])
              }
              if (is.null(ylim)) {
                ylim = c(min(object[Columns, 2]), max(object[Columns, 3]))
              }

              # Point estimates
              plot(x = Columns,
                   y = object[Columns, 1],
                   xlab = xlab,
                   ylab = ylab,
                   ylim = ylim,
                   pch = pch,
                   col = col,
                   bty = bty,
                   ...
              )

              # Add HPD interval
              for (Column in Columns) {
                BarLength <- ifelse(length(Columns) <= 10,
                                    0.1,
                                    2 / length(Columns))

                segments(x0 = Column,
                         y0 = object[Column, 2],
                         y1 = object[Column, 3],
                         col = col)
                segments(x0 = Column - BarLength,
                         y0 = object[Column, 2],
                         x1 = Column + BarLength,
                         col = col)
                segments(x0 = Column - BarLength,
                         y0 = object[Column, 3],
                         x1 = Column + BarLength,
                         col = col)
              }

          } else {
            if (!Param2 %in% names(x@parameters)) {
              stop("'Param2' is not a parameter in this BASiCS_Summary object")
            }
            HiddenCheckValidCombination(Param, Param2)
            if (SmoothPlot) {
              col <- grDevices::rgb(grDevices::col2rgb(col)[1],
                                    grDevices::col2rgb(col)[2],
                                    grDevices::col2rgb(col)[3],
                                    50,
                                    maxColorValue = 255)
            }
            if (Param %in% HiddenGeneParams()) {
              Columns <- Genes
              ylabInd <- "i"
            }
            if (Param %in% HiddenCellParams()) {
              Columns <- Cells
              ylabInd <- "j"
            }
            graphics::plot(
              x@parameters[[Param]][Columns, 1],
              x@parameters[[Param2]][Columns, 1],
              xlab = bquote(.(Param)[.(ylabInd)]),
              ylab = bquote(.(Param2)[.(ylabInd)]),
              xlim = c(
                min(x@parameters[[Param]][Columns, 1]),
                max(x@parameters[[Param]][Columns, 1])
              ),
              ylim = c(
                min(x@parameters[[Param2]][Columns, 1]),
                max(x@parameters[[Param2]][Columns, 1])
              ),
              pch = pch,
              col = col,
              bty = bty,
              ...
            )
          }
        })


#' @name displaySummaryBASiCS-BASiCS_Summary-method
#' @aliases displaySummaryBASiCS displaySummaryBASiCS,BASiCS_Summary-method
#'
#' @docType methods
#' @rdname displaySummaryBASiCS-BASiCS_Summary-method
#'
#' @title Accessors for the slots of a \code{\linkS4class{BASiCS_Summary}} object
#'
#' @description Accessors for the slots of a \code{\linkS4class{BASiCS_Summary}}
#' object
#'
#' @param object an object of class \code{\linkS4class{BASiCS_Summary}}
#' @param Param Name of the slot to be used for the accessed.
#' Possible values: \code{'mu'}, \code{'delta'}, \code{'phi'},
#' \code{'s'}, \code{'nu'}, \code{'theta'}, \code{'beta'},
#' \code{'sigma2'} and \code{'epsilon'}.
#'
#' @return The requested slot of a \code{\linkS4class{BASiCS_Summary}} object
#'
#' @examples
#'
#' help(BASiCS_MCMC)
#'
#' @seealso \code{\linkS4class{BASiCS_Summary}}
#'
#' @author Catalina A. Vallejos \email{cnvallej@@uc.cl}
#' @author Nils Eling \email{eling@@ebi.ac.uk}
#'
#' @export
setMethod("displaySummaryBASiCS",
          signature = "BASiCS_Summary",
          definition = HiddenGetParam)

#' @export
setMethod("show", signature = "BASiCS_OffsetCorrected", 
  function(object) {
    message("A BASiCS_OffsetCorrected object for ", object@GroupLabel1, " and ",
      object@GroupLabel2, ". To test for differential expression run ", 
      "`BASiCS_TestDE(OffsetCorrected = OffsetCorrected)`", sep = "")
  }
)

#' @export
setMethod("show", signature = "BASiCS_ResultsDE", 
  function(object) {
    for (x in object@Results) {
      print(x)
    }
  }
)

#' @export
setMethod("show", signature = "BASiCS_ResultDE", 
  function(object) {
    diffName <- paste0("ResultDiff", object@Name)
    
    nPlus1 <- sum(object@Table[[diffName]] == paste0(object@GroupLabel1, "+"))
    nPlus2 <- sum(object@Table[[diffName]] == paste0(object@GroupLabel2, "+"))
    message(
      "-------------------------------------------------------------\n",
      nPlus1 + nPlus2," genes with a change in ", MeasureName(object@Name), ":\n",
      "- Higher ", MeasureName(object@Name), " in ", 
      object@GroupLabel1, " samples: ", nPlus1, "\n",
      "- Higher ", MeasureName(object@Name), " in ", 
      object@GroupLabel2, " samples: ", nPlus2, "\n",
      "- ", cap(DistanceName(object@Name)), 
          " tolerance = ", round(2^(object@Epsilon) * 100, 2), "% \n",
      "- Probability threshold = ", object@ProbThreshold, "\n",
      "- EFDR = ", round(100 * object@EFDR, 2), "% \n",
      "- EFNR = ", round(100 * object@EFNR, 2), "% \n"
    )
    if (object@Name == "delta") {
      NotDE <- sum(object@Table[[diffName]]  == "ExcludedFromTesting")
      message(
        "NOTE: differential dispersion assessment only applied to the \n",
        sum(NotDE), " genes for which the mean did not change. \n",
        "and that were included for testing. \n"
      )
    } else if (object@Name == "epsilon") {
      NotExcluded <- sum(object@Table[[diffName]] != "ExcludedFromTesting")
      message(
        "NOTE: differential residual dispersion assessment applied to \n",
        sum(NotExcluded), " genes expressed in at least 2 cells per condition \n",
        "and that were included for testing. \n"
      )
    }
    message("-------------------------------------------------------------\n\n")
  }
)
